
<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Gravity Dash</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Rajdhani', sans-serif;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        .font-orbitron { font-family: 'Orbitron', sans-serif; }
        
        /* CRT Tarama Çizgisi Efekti */
        .crt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 3px 100%;
            pointer-events: none;
            z-index: 50;
            opacity: 0.2;
        }

        .neon-border {
            box-shadow: 0 0 10px rgba(0, 242, 255, 0.5), inset 0 0 10px rgba(0, 242, 255, 0.2);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
        }
        .animate-pulse-slow { animation: pulse 3s infinite ease-in-out; }
        
        @keyframes flicker {
            0% { opacity: 1; }
            5% { opacity: 0.8; }
            10% { opacity: 1; }
            15% { opacity: 0.9; }
            20% { opacity: 1; }
            100% { opacity: 1; }
        }
        .animate-flicker { animation: flicker 4s infinite; }

        canvas {
            display: block;
            image-rendering: pixelated;
        }
    </style>
</head>
<body>
    <div class="crt-overlay"></div>
    <div id="root"></div>

    <script type="module">
        import React, { useState, useEffect, useRef, useCallback } from 'https://esm.sh/react@19.0.0';
        import ReactDOM from 'https://esm.sh/react-dom@19.0.0/client';
        import htm from 'https://esm.sh/htm';

        const html = htm.bind(React.createElement);

        // --- Sabitler ---
        const GAME_WIDTH = 400;
        const GAME_HEIGHT = 700;
        const PLAYER_SIZE = 30;
        const PLAYER_X = 60;
        const GRAVITY = 0.8;
        const INITIAL_SPEED = 5;
        const MAX_SPEED = 14;
        const SPEED_INCREMENT = 0.0003;
        const FLOOR_HEIGHT = 45;
        const OBSTACLE_MIN_GAP = 280;
        const SPAWN_PROBABILITY = 0.025;
        const POWERUP_SPAWN_PROBABILITY = 0.006;
        const POWERUP_DURATION = 6000;

        const COLORS = {
            PLAYER: '#00f2ff',
            PLAYER_GLOW: '#00f2ff',
            OBSTACLE: '#ff0055',
            OBSTACLE_GLOW: '#ff0055',
            GRID: 'rgba(0, 242, 255, 0.15)',
            BACKGROUND: '#050505',
            CITY_LIGHTS: 'rgba(0, 242, 255, 0.03)',
            CEILING_FLOOR: '#0a0a0a',
            SHIELD: '#00ffaa',
            BOOST: '#ffff00',
            MULTIPLIER: '#bf00ff'
        };

        const GameStatus = { START: 'START', TUTORIAL: 'TUTORIAL', PLAYING: 'PLAYING', GAMEOVER: 'GAMEOVER' };
        const Language = { EN: 'EN', TR: 'TR', JP: 'JP', ES: 'ES' };
        const ObstacleType = { BLOCK: 'BLOCK', SPIKE: 'SPIKE' };
        const PowerUpType = { SHIELD: 'SHIELD', BOOST: 'BOOST', MULTIPLIER: 'MULTIPLIER' };

        const TRANSLATIONS = {
            [Language.EN]: { 
                title1: "NEON", title2: "GRAVITY DASH", initiate: "INITIATE", skip: "SKIP CALIBRATION", instructions1: "TAP TO SHIFT GRAVITY", instructions2: "AVOID LETHAL SPIKES", 
                systemRecord: "System Record", systemCollapse: "SYSTEM COLLAPSE", coreYield: "Core Yield", reSync: "RE-SYNC", bestSync: "Best Sync", node: "NODE",
                tutFlip: "TAP TO FLIP GRAVITY", tutDodge: "DODGE THE SPIKES", tutPower: "COLLECT POWER-UPS", tutReady: "SYSTEM CALIBRATED. GO!"
            },
            [Language.TR]: { 
                title1: "NEON", title2: "GRAVITY DASH", initiate: "BAŞLAT", skip: "AYARLARI ATLA", instructions1: "YERÇEKİMİNİ DEĞİŞTİRMEK İÇİN DOKUN", instructions2: "ÖLÜMCÜL ENGELLERDEN KAÇIN", 
                systemRecord: "Sistem Kaydı", systemCollapse: "SİSTEM ÇÖKTÜ", coreYield: "Çekirdek Verimi", reSync: "TEKRAR SENK", bestSync: "En İyi Senk", node: "DÜĞÜM",
                tutFlip: "YERÇEKİMİNİ DEĞİŞTİRMEK İÇİN DOKUN", tutDodge: "ENGELLERDEN KAÇIN", tutPower: "GÜÇLENDİRMELERİ TOPLA", tutReady: "SİSTEM AYARLANDI. BAŞLA!"
            },
            [Language.JP]: { 
                title1: "ネオン", title2: "グラビティ・ダッシュ", initiate: "起動", skip: "スキップ", instructions1: "タップで重力を反転", instructions2: "障害物を回避せよ", 
                systemRecord: "システム記録", systemCollapse: "システム崩壊", coreYield: "コア出力", reSync: "再同期", bestSync: "最高同期", node: "ノード",
                tutFlip: "タップで重力を反転", tutDodge: "スパイクを回避", tutPower: "パワーアップを回収", tutReady: "システム調整完了。GO!"
            },
            [Language.ES]: { 
                title1: "NEÓN", title2: "GRAVITY DASH", initiate: "INICIAR", skip: "SALTAR", instructions1: "PULSA PARA CAMBIAR GRAVEDAD", instructions2: "EVITA PICOS LETALES", 
                systemRecord: "Récord del Sistema", systemCollapse: "COLAPSO DEL SISTEMA", coreYield: "Rendimiento", reSync: "RE-SINCRONIZAR", bestSync: "Mejor Sincro", node: "NODO",
                tutFlip: "PULSA PARA CAMBIAR GRAVEDAD", tutDodge: "ESQUIVA LOS PICOS", tutPower: "RECOGE MEJORAS", tutReady: "SISTEMA CALIBRADO. ¡VAMOS!"
            }
        };

        // --- GameCanvas Bileşeni ---
        const GameCanvas = ({ status, onGameOver, onTutorialComplete, language }) => {
            const canvasRef = useRef(null);
            const requestRef = useRef();
            const lastTimeRef = useRef();
            const audioCtxRef = useRef(null);
            const t = TRANSLATIONS[language];
            
            const gameState = useRef({
                player: { y: GAME_HEIGHT - FLOOR_HEIGHT - PLAYER_SIZE, width: PLAYER_SIZE, height: PLAYER_SIZE, isGrounded: true, gravityInverted: false, velocity: 0, color: COLORS.PLAYER, glow: COLORS.PLAYER_GLOW },
                obstacles: [], powerUps: [], particles: [], bgShapes: [], bgRain: [],
                score: 0, gameSpeed: INITIAL_SPEED, distanceTraveled: 0, lastSpawnX: 0, startTime: 0,
                isDying: false, playerVisible: true, screenShake: 0, flashOpacity: 0, transitionWipe: 0, glitchTimer: 0,
                activePowerUps: { [PowerUpType.SHIELD]: 0, [PowerUpType.BOOST]: 0, [PowerUpType.MULTIPLIER]: 0 },
                tutorialStep: 0, tutorialWait: 0, hasFlipped: false
            });

            const initAudio = () => {
                if (!audioCtxRef.current) audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)();
                if (audioCtxRef.current.state === 'suspended') audioCtxRef.current.resume();
            };

            const playSound = (type) => {
                const ctx = audioCtxRef.current;
                if (!ctx) return;
                const masterGain = ctx.createGain();
                masterGain.gain.setValueAtTime(0.15, ctx.currentTime);
                masterGain.connect(ctx.destination);

                if (type === 'flip') {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(gameState.current.player.gravityInverted ? 440 : 220, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(gameState.current.player.gravityInverted ? 880 : 110, ctx.currentTime + 0.1);
                    gain.gain.setValueAtTime(0.3, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                    osc.connect(gain); gain.connect(masterGain);
                    osc.start(); osc.stop(ctx.currentTime + 0.1);
                } else if (type === 'powerup') {
                    [440, 554.37, 659.25, 880].forEach((f, i) => {
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(f, ctx.currentTime + i * 0.05);
                        gain.gain.setValueAtTime(0.2, ctx.currentTime + i * 0.05);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.05 + 0.2);
                        osc.connect(gain); gain.connect(masterGain);
                        osc.start(ctx.currentTime + i * 0.05); osc.stop(ctx.currentTime + i * 0.05 + 0.2);
                    });
                } else if (type === 'death') {
                    const noiseBuffer = ctx.createBuffer(1, ctx.sampleRate * 0.5, ctx.sampleRate);
                    const output = noiseBuffer.getChannelData(0);
                    for (let i = 0; i < ctx.sampleRate * 0.5; i++) output[i] = Math.random() * 2 - 1;
                    const noise = ctx.createBufferSource();
                    noise.buffer = noiseBuffer;
                    const filter = ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(1000, ctx.currentTime);
                    filter.frequency.exponentialRampToValueAtTime(40, ctx.currentTime + 0.4);
                    const gain = ctx.createGain();
                    gain.gain.setValueAtTime(0.5, ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.5);
                    noise.connect(filter); filter.connect(gain); gain.connect(masterGain);
                    noise.start();
                }
            };

            const resetGame = useCallback((isTutorial = false) => {
                initAudio();
                const shapes = [];
                for (let i = 0; i < 15; i++) shapes.push({ x: Math.random() * GAME_WIDTH, y: Math.random() * GAME_HEIGHT, size: 20 + Math.random() * 60, sides: Math.random() > 0.5 ? 3 : 6, rotation: Math.random() * Math.PI * 2, rotationSpeed: (Math.random() - 0.5) * 0.01, opacity: 0.03 + Math.random() * 0.05 });
                const rain = [];
                const rainColors = [COLORS.PLAYER, COLORS.OBSTACLE, COLORS.SHIELD];
                for (let i = 0; i < 60; i++) rain.push({ x: Math.random() * GAME_WIDTH, y: Math.random() * GAME_HEIGHT, speed: 10 + Math.random() * 15, length: 15 + Math.random() * 25, color: rainColors[Math.floor(Math.random() * rainColors.length)] });

                gameState.current = {
                    player: { y: GAME_HEIGHT - FLOOR_HEIGHT - PLAYER_SIZE, width: PLAYER_SIZE, height: PLAYER_SIZE, isGrounded: true, gravityInverted: false, velocity: 0, color: COLORS.PLAYER, glow: COLORS.PLAYER_GLOW },
                    obstacles: [], powerUps: [], particles: [], bgShapes: shapes, bgRain: rain,
                    score: 0, gameSpeed: isTutorial ? 3 : INITIAL_SPEED, distanceTraveled: 0, lastSpawnX: 200, startTime: Date.now(),
                    isDying: false, playerVisible: true, screenShake: 0, flashOpacity: 0, transitionWipe: 1.0, glitchTimer: 0,
                    activePowerUps: { [PowerUpType.SHIELD]: 0, [PowerUpType.BOOST]: 0, [PowerUpType.MULTIPLIER]: 0 },
                    tutorialStep: isTutorial ? 1 : 0, tutorialWait: 0, hasFlipped: false
                };
            }, []);

            const triggerDeath = useCallback(() => {
                const gs = gameState.current;
                if (gs.isDying) return;
                gs.isDying = true; gs.playerVisible = false; gs.screenShake = 30; gs.glitchTimer = 1.0;
                playSound('death');
                for (let i = 0; i < 80; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 15;
                    gs.particles.push({ x: PLAYER_X + PLAYER_SIZE / 2, y: gs.player.y + PLAYER_SIZE / 2, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 1.0 + Math.random(), maxLife: 2.0, color: COLORS.PLAYER });
                }
                setTimeout(() => onGameOver(gs.score), 1200);
            }, [onGameOver]);

            const toggleGravity = useCallback(() => {
                if ((status !== GameStatus.PLAYING && status !== GameStatus.TUTORIAL) || gameState.current.isDying) return;
                gameState.current.player.gravityInverted = !gameState.current.player.gravityInverted;
                gameState.current.player.isGrounded = false;
                gameState.current.hasFlipped = true;
                playSound('flip');
                for (let i = 0; i < 15; i++) {
                    gameState.current.particles.push({ x: PLAYER_X + PLAYER_SIZE / 2, y: gameState.current.player.y + PLAYER_SIZE / 2, vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10, life: 0.8, maxLife: 1.0, color: COLORS.PLAYER });
                }
            }, [status]);

            const update = useCallback((deltaTime) => {
                const gs = gameState.current;
                if (status !== GameStatus.PLAYING && status !== GameStatus.TUTORIAL) return;
                const dtScale = deltaTime / 16.6;
                const now = Date.now();
                if (gs.transitionWipe > 0) gs.transitionWipe = Math.max(0, gs.transitionWipe - 0.03 * dtScale);
                if (gs.screenShake > 0) gs.screenShake *= 0.9;
                if (gs.flashOpacity > 0) gs.flashOpacity -= 0.05 * dtScale;
                gs.bgRain.forEach(p => { p.y += p.speed * dtScale; if (p.y > GAME_HEIGHT) { p.y = -p.length; p.x = Math.random() * GAME_WIDTH; } });

                if (gs.isDying) {
                    gs.glitchTimer = Math.max(0, gs.glitchTimer - 0.01 * dtScale);
                    gs.screenShake = Math.max(5, gs.screenShake * 0.95);
                    gs.particles.forEach(part => { part.x += part.vx * dtScale; part.y += part.vy * dtScale; part.vx *= 0.98; part.vy *= 0.98; part.life -= 0.012 * dtScale; });
                    gs.particles = gs.particles.filter(p => p.life > 0);
                    return;
                }

                if (status === GameStatus.TUTORIAL) {
                    if (gs.tutorialStep === 1) {
                        if (gs.hasFlipped) {
                            gs.tutorialWait += deltaTime;
                            if (gs.tutorialWait > 1000) { gs.tutorialStep = 2; gs.tutorialWait = 0; gs.lastSpawnX = gs.distanceTraveled; }
                        }
                    } else if (gs.tutorialStep === 2) {
                        if (gs.obstacles.length === 0 && gs.tutorialWait === 0) {
                            gs.obstacles.push({ x: GAME_WIDTH + 50, y: GAME_HEIGHT - FLOOR_HEIGHT - 45, width: 45, height: 45, type: ObstacleType.SPIKE, position: 'bottom' });
                            gs.tutorialWait = 1;
                        }
                        if (gs.obstacles.length === 0 && gs.tutorialWait > 0) {
                            gs.tutorialStep = 3; gs.tutorialWait = 0;
                        }
                    } else if (gs.tutorialStep === 3) {
                        if (gs.powerUps.length === 0 && gs.tutorialWait === 0) {
                            gs.powerUps.push({ x: GAME_WIDTH + 50, y: FLOOR_HEIGHT + 30, width: 35, height: 35, type: PowerUpType.SHIELD, collected: false, pulseScale: 1 });
                            gs.tutorialWait = 1;
                        }
                        if (gs.activePowerUps[PowerUpType.SHIELD] > 0) {
                            gs.tutorialStep = 4; gs.tutorialWait = 0;
                        }
                    } else if (gs.tutorialStep === 4) {
                        gs.tutorialWait += deltaTime;
                        if (gs.tutorialWait > 2000) onTutorialComplete();
                    }
                }

                Object.keys(gs.activePowerUps).forEach((key) => { if (gs.activePowerUps[key] > 0) gs.activePowerUps[key] = Math.max(0, gs.activePowerUps[key] - deltaTime); });
                let effectiveSpeed = gs.gameSpeed;
                if (gs.activePowerUps[PowerUpType.BOOST] > 0) effectiveSpeed *= 1.7;
                
                if (status === GameStatus.PLAYING) gs.gameSpeed = Math.min(MAX_SPEED, gs.gameSpeed + SPEED_INCREMENT * deltaTime);
                gs.distanceTraveled += effectiveSpeed;
                gs.score = Math.floor(((now - gs.startTime) / 1000) * (gs.activePowerUps[PowerUpType.MULTIPLIER] > 0 ? 2 : 1));

                gs.bgShapes.forEach(shape => { shape.rotation += shape.rotationSpeed * dtScale; });
                const p = gs.player;
                const gravityDir = p.gravityInverted ? -1 : 1;
                p.velocity += GRAVITY * gravityDir * dtScale;
                p.y += p.velocity * dtScale;
                const floorLimit = GAME_HEIGHT - FLOOR_HEIGHT - p.height;
                const ceilingLimit = FLOOR_HEIGHT;
                if (p.y > floorLimit) { p.y = floorLimit; p.velocity = 0; p.isGrounded = !p.gravityInverted; }
                else if (p.y < ceilingLimit) { p.y = ceilingLimit; p.velocity = 0; p.isGrounded = p.gravityInverted; }
                else p.isGrounded = false;

                gs.obstacles.forEach(obs => { obs.x -= effectiveSpeed * dtScale; });
                gs.obstacles = gs.obstacles.filter(obs => obs.x + obs.width > -50);
                gs.powerUps.forEach(pu => { pu.x -= effectiveSpeed * dtScale; pu.pulseScale = 1 + Math.sin(now / 150) * 0.15; });
                gs.powerUps = gs.powerUps.filter(pu => !pu.collected && pu.x + pu.width > -50);

                if (status === GameStatus.PLAYING && gs.distanceTraveled - gs.lastSpawnX > OBSTACLE_MIN_GAP) {
                    if (Math.random() < SPAWN_PROBABILITY * (gs.gameSpeed / INITIAL_SPEED)) {
                        const type = Math.random() > 0.5 ? ObstacleType.BLOCK : ObstacleType.SPIKE;
                        const obsWidth = 35 + Math.random() * 25;
                        const obsHeight = type === ObstacleType.SPIKE ? 45 : 45 + Math.random() * 35;
                        gs.obstacles.push({ x: GAME_WIDTH + 50, y: Math.random() > 0.5 ? FLOOR_HEIGHT : GAME_HEIGHT - FLOOR_HEIGHT - obsHeight, width: obsWidth, height: obsHeight, type, position: Math.random() > 0.5 ? 'top' : 'bottom' });
                        gs.lastSpawnX = gs.distanceTraveled;
                    }
                    if (Math.random() < POWERUP_SPAWN_PROBABILITY) {
                        const types = [PowerUpType.SHIELD, PowerUpType.BOOST, PowerUpType.MULTIPLIER];
                        gs.powerUps.push({ x: GAME_WIDTH + 100, y: Math.random() > 0.5 ? FLOOR_HEIGHT + 30 : GAME_HEIGHT - FLOOR_HEIGHT - 60, width: 35, height: 35, type: types[Math.floor(Math.random() * types.length)], collected: false, pulseScale: 1 });
                    }
                }

                for (const pu of gs.powerUps) {
                    if (PLAYER_X < pu.x + pu.width && PLAYER_X + PLAYER_SIZE > pu.x && p.y < pu.y + pu.height && p.y + PLAYER_SIZE > pu.y) {
                        pu.collected = true; gs.activePowerUps[pu.type] = POWERUP_DURATION; gs.flashOpacity = 0.4; playSound('powerup');
                    }
                }
                for (const obs of gs.obstacles) {
                    if (PLAYER_X + 5 < obs.x + obs.width && PLAYER_X + PLAYER_SIZE - 5 > obs.x && p.y + 5 < obs.y + obs.height && p.y + PLAYER_SIZE - 5 > obs.y) {
                        if (gs.activePowerUps[PowerUpType.SHIELD] > 0) { gs.activePowerUps[PowerUpType.SHIELD] = 0; gs.obstacles = gs.obstacles.filter(o => o !== obs); gs.screenShake = 10; playSound('death'); }
                        else { triggerDeath(); return; }
                    }
                }
                gs.particles.forEach(part => { part.x += part.vx * dtScale; part.y += part.vy * dtScale; part.life -= 0.02 * dtScale; });
                gs.particles = gs.particles.filter(p => p.life > 0);
            }, [status, triggerDeath, onTutorialComplete]);

            const draw = useCallback((ctx) => {
                const gs = gameState.current; const now = Date.now();
                ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.fillStyle = COLORS.BACKGROUND; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                if (gs.screenShake > 0.1) ctx.translate((Math.random() - 0.5) * gs.screenShake, (Math.random() - 0.5) * gs.screenShake);
                
                ctx.save(); ctx.lineWidth = 1; gs.bgRain.forEach(p => { ctx.strokeStyle = p.color; ctx.globalAlpha = 0.15; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y + p.length); ctx.stroke(); }); ctx.restore();

                const farDist = gs.distanceTraveled * 0.1; ctx.fillStyle = COLORS.CITY_LIGHTS;
                for (let i = 0; i < 10; i++) {
                    const xPos = (i * 120 - farDist) % (GAME_WIDTH + 120); const h = 50 + Math.sin(i * 1.5) * 30;
                    ctx.fillRect(xPos, GAME_HEIGHT - FLOOR_HEIGHT - h, 80, h); ctx.fillRect(xPos + 20, FLOOR_HEIGHT, 40, h * 0.6);
                }

                const midParallax = gs.distanceTraveled * 0.25;
                gs.bgShapes.forEach(shape => {
                    ctx.save(); const x = ((shape.x - midParallax) % (GAME_WIDTH + 200)) - 100;
                    ctx.translate(x, shape.y); ctx.rotate(shape.rotation); ctx.globalAlpha = shape.opacity; ctx.strokeStyle = COLORS.PLAYER; ctx.lineWidth = 1;
                    ctx.beginPath(); const step = (Math.PI * 2) / shape.sides;
                    for (let i = 0; i < shape.sides; i++) { const ax = Math.cos(i * step) * shape.size, ay = Math.sin(i * step) * shape.size; if (i === 0) ctx.moveTo(ax, ay); else ctx.lineTo(ax, ay); }
                    ctx.closePath(); ctx.stroke(); ctx.restore();
                });

                gs.obstacles.forEach(obs => {
                    ctx.save(); const pulse = Math.sin(now / 150) * 0.5 + 0.5, flicker = Math.random() > 0.95 ? 1.5 : 1.0;
                    ctx.shadowBlur = (25 + pulse * 25) * flicker; ctx.shadowColor = COLORS.OBSTACLE_GLOW; ctx.globalAlpha = 0.3 + pulse * 0.4;
                    if (obs.type === ObstacleType.SPIKE) {
                        ctx.beginPath(); const tipY = obs.y + (obs.y < GAME_HEIGHT / 2 ? obs.height : 0), baseY = obs.y + (obs.y < GAME_HEIGHT / 2 ? 0 : obs.height);
                        ctx.moveTo(obs.x, baseY); ctx.lineTo(obs.x + obs.width, baseY); ctx.lineTo(obs.x + obs.width / 2, tipY); ctx.fill();
                        ctx.globalAlpha = 1.0; ctx.fillStyle = COLORS.OBSTACLE; ctx.fill();
                    } else {
                        ctx.fillRect(obs.x, obs.y, obs.width, obs.height); ctx.globalAlpha = 1.0; ctx.fillStyle = COLORS.OBSTACLE; ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                    } ctx.restore();
                });

                ctx.fillStyle = COLORS.CEILING_FLOOR; ctx.fillRect(0, 0, GAME_WIDTH, FLOOR_HEIGHT); ctx.fillRect(0, GAME_HEIGHT - FLOOR_HEIGHT, GAME_WIDTH, FLOOR_HEIGHT);
                ctx.strokeStyle = COLORS.PLAYER; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, FLOOR_HEIGHT); ctx.lineTo(GAME_WIDTH, FLOOR_HEIGHT); ctx.moveTo(0, GAME_HEIGHT - FLOOR_HEIGHT); ctx.lineTo(GAME_WIDTH, GAME_HEIGHT - FLOOR_HEIGHT); ctx.stroke();

                gs.powerUps.forEach(pu => {
                    ctx.save(); const color = pu.type === PowerUpType.SHIELD ? COLORS.SHIELD : pu.type === PowerUpType.BOOST ? COLORS.BOOST : COLORS.MULTIPLIER;
                    ctx.translate(pu.x + pu.width/2, pu.y + pu.height/2); ctx.scale(pu.pulseScale, pu.pulseScale); ctx.shadowBlur = 20; ctx.shadowColor = color; ctx.fillStyle = color;
                    ctx.beginPath(); if (pu.type === PowerUpType.SHIELD) ctx.arc(0,0,14,0,Math.PI*2); else if (pu.type === PowerUpType.BOOST) { ctx.moveTo(-12,10); ctx.lineTo(0,-14); ctx.lineTo(12,10); ctx.closePath(); } else ctx.fillRect(-12,-12,24,24);
                    ctx.fill(); ctx.restore();
                });

                gs.particles.forEach(p => { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, 5, 5); }); ctx.globalAlpha = 1.0;

                if (gs.playerVisible) {
                    const p = gs.player; ctx.save(); ctx.shadowBlur = 25; ctx.shadowColor = COLORS.PLAYER_GLOW; ctx.fillStyle = COLORS.PLAYER; ctx.fillRect(PLAYER_X, p.y, p.width, p.height);
                    if (gs.activePowerUps[PowerUpType.SHIELD] > 0) { ctx.strokeStyle = COLORS.SHIELD; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(PLAYER_X + PLAYER_SIZE/2, p.y + PLAYER_SIZE/2, PLAYER_SIZE * 0.9, 0, Math.PI*2); ctx.stroke(); } ctx.restore();
                }

                if (gs.isDying && gs.glitchTimer > 0) {
                    const intensity = gs.glitchTimer;
                    for (let i = 0; i < 10; i++) { const h = GAME_HEIGHT / 10, y = i * h, offsetX = (Math.random() - 0.5) * 50 * intensity; ctx.drawImage(ctx.canvas, 0, y, GAME_WIDTH, h, offsetX, y, GAME_WIDTH, h); }
                }
                if (gs.flashOpacity > 0.01) { ctx.fillStyle = `rgba(255, 255, 255, ${gs.flashOpacity})`; ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT); }
                if (gs.transitionWipe > 0) {
                    const wipeX = (1 - gs.transitionWipe) * GAME_WIDTH; ctx.save(); ctx.fillStyle = COLORS.PLAYER; ctx.shadowBlur = 20; ctx.shadowColor = COLORS.PLAYER_GLOW; ctx.fillRect(wipeX, 0, 4, GAME_HEIGHT); ctx.restore();
                }

                if (status === GameStatus.PLAYING) {
                    ctx.fillStyle = gs.activePowerUps[PowerUpType.MULTIPLIER] > 0 ? COLORS.MULTIPLIER : '#fff'; ctx.font = 'bold 32px Orbitron'; ctx.textAlign = 'right'; ctx.fillText(gs.score.toString(), GAME_WIDTH - 20, 50);
                } else if (status === GameStatus.TUTORIAL) {
                    ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.fillStyle = '#fff'; ctx.font = 'bold 20px Orbitron'; ctx.textAlign = 'center';
                    let tutMsg = "";
                    if (gs.tutorialStep === 1) tutMsg = t.tutFlip;
                    else if (gs.tutorialStep === 2) tutMsg = t.tutDodge;
                    else if (gs.tutorialStep === 3) tutMsg = t.tutPower;
                    else if (gs.tutorialStep === 4) tutMsg = t.tutReady;
                    if (tutMsg) { ctx.shadowBlur = 10; ctx.shadowColor = COLORS.PLAYER_GLOW; ctx.fillText(tutMsg, GAME_WIDTH / 2, GAME_HEIGHT / 2 - 100); }
                }
            }, [status, t]);

            const animate = useCallback((time) => {
                if (lastTimeRef.current !== undefined) update(time - lastTimeRef.current);
                const ctx = canvasRef.current?.getContext('2d'); if (ctx) draw(ctx);
                lastTimeRef.current = time; requestRef.current = requestAnimationFrame(animate);
            }, [update, draw]);

            useEffect(() => { 
                if (status === GameStatus.PLAYING) resetGame(false); 
                else if (status === GameStatus.TUTORIAL) resetGame(true);
                requestRef.current = requestAnimationFrame(animate); 
                return () => cancelAnimationFrame(requestRef.current); 
            }, [status, animate, resetGame]);

            useEffect(() => {
                const handleAction = (e) => { 
                    e.preventDefault(); 
                    if (status === GameStatus.PLAYING || status === GameStatus.TUTORIAL) { 
                        initAudio(); toggleGravity(); 
                    } 
                };
                const cv = canvasRef.current;
                if (cv) { cv.addEventListener('mousedown', handleAction); cv.addEventListener('touchstart', handleAction, { passive: false }); }
                return () => { if (cv) { cv.removeEventListener('mousedown', handleAction); cv.removeEventListener('touchstart', handleAction); } };
            }, [toggleGravity, status]);

            return html`<canvas ref=${canvasRef} width=${GAME_WIDTH} height=${GAME_HEIGHT} className="w-full h-full object-contain cursor-pointer" />`;
        };

        const App = () => {
            const [status, setStatus] = useState(GameStatus.START);
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(0);
            const [language, setLanguage] = useState(Language.TR);

            useEffect(() => {
                const savedScore = localStorage.getItem('neon-gravity-highscore');
                if (savedScore) setHighScore(parseInt(savedScore, 10));
                const savedLang = localStorage.getItem('neon-gravity-lang');
                if (savedLang && Object.values(Language).includes(savedLang)) setLanguage(savedLang);
            }, []);

            const handleGameOver = useCallback((finalScore) => {
                setScore(finalScore);
                if (finalScore > highScore) { setHighScore(finalScore); localStorage.setItem('neon-gravity-highscore', finalScore.toString()); }
                setStatus(GameStatus.GAMEOVER);
            }, [highScore]);

            const startTutorial = () => setStatus(GameStatus.TUTORIAL);
            const onTutorialComplete = () => setStatus(GameStatus.PLAYING);
            const startGameDirectly = () => { setStatus(GameStatus.PLAYING); setScore(0); };
            const changeLanguage = (lang) => { setLanguage(lang); localStorage.setItem('neon-gravity-lang', lang); };
            const t = TRANSLATIONS[language];

            return html`
                <div className="relative w-full h-screen bg-[#050505] flex items-center justify-center overflow-hidden">
                    <div className="relative w-full max-w-[400px] h-full max-h-[700px] shadow-[0_0_100px_rgba(0,242,255,0.15)] border-x border-cyan-500/20 bg-black overflow-hidden">
                        
                        <${GameCanvas} status=${status} onGameOver=${handleGameOver} onTutorialComplete=${onTutorialComplete} language=${language} />

                        ${status === GameStatus.START && html`
                            <div className="absolute inset-0 z-10 flex flex-col items-center justify-center bg-black/85 backdrop-blur-md p-6 text-center">
                                <div className="absolute top-6 flex gap-3 z-20">
                                    ${Object.values(Language).map(lang => html`
                                        <button key=${lang} onClick=${() => changeLanguage(lang)} className=${`px-2 py-1 text-[10px] font-orbitron border transition-all ${language === lang ? 'border-cyan-400 text-cyan-400 shadow-[0_0_10px_rgba(34,211,238,0.5)]' : 'border-white/10 text-white/30 hover:border-white/30'}`}>${lang}</button>
                                    `)}
                                </div>
                                <div className="animate-pulse-slow mb-12">
                                    <h1 className="text-6xl font-orbitron font-black text-cyan-400 leading-none drop-shadow-[0_0_20px_rgba(34,211,238,0.8)] animate-flicker">${t.title1}</h1>
                                    <h2 className="text-3xl font-orbitron font-bold text-pink-500 italic tracking-widest mt-[-5px]">${t.title2}</h2>
                                </div>
                                <div className="space-y-4 w-full max-w-[280px]">
                                    <button onClick=${startTutorial} className="w-full py-5 bg-transparent border-2 border-cyan-400 text-cyan-400 hover:bg-cyan-400/10 font-bold text-2xl tracking-[0.2em] transition-all active:scale-95 font-orbitron neon-border uppercase">${t.initiate}</button>
                                    <button onClick=${startGameDirectly} className="w-full py-2 bg-transparent text-cyan-400/40 hover:text-cyan-400 font-orbitron text-[10px] tracking-widest transition-all uppercase">${t.skip}</button>
                                    <div className="flex flex-col gap-2 text-cyan-400/20 font-rajdhani tracking-widest text-xs uppercase pt-8"><p>${t.instructions1}</p><p>${t.instructions2}</p></div>
                                </div>
                                ${highScore > 0 && html`<div className="mt-16 border-t border-pink-500/20 pt-4 w-full"><div className="text-pink-500/60 font-orbitron text-[10px] uppercase tracking-[0.3em]">${t.systemRecord}</div><div className="text-pink-400 font-orbitron text-2xl font-bold">${highScore}</div></div>`}
                            </div>
                        `}

                        ${status === GameStatus.GAMEOVER && html`
                            <div className="absolute inset-0 z-10 flex flex-col items-center justify-center bg-black/90 backdrop-blur-xl p-6 text-center">
                                <h2 className="text-2xl font-orbitron font-bold text-pink-600 mb-1 tracking-widest uppercase animate-flicker">${t.systemCollapse}</h2>
                                <div className="w-16 h-[2px] bg-pink-600/50 mb-8"></div>
                                <div className="mb-12">
                                    <div className="text-cyan-400/40 text-xs font-orbitron tracking-widest mb-2 uppercase">${t.coreYield}</div>
                                    <div className="text-cyan-400 text-7xl font-black font-orbitron drop-shadow-[0_0_15px_rgba(0,242,255,0.6)]">${score}</div>
                                </div>
                                <div className="space-y-4 w-full max-w-[260px]">
                                    <button onClick=${startGameDirectly} className="w-full py-5 bg-pink-600 hover:bg-pink-500 text-white font-bold text-xl tracking-[0.2em] transition-all active:scale-95 shadow-[0_0_20px_rgba(236,72,153,0.4)] font-orbitron uppercase">${t.reSync}</button>
                                    <div className="mt-8">
                                        <div className="text-pink-500/40 text-[10px] font-orbitron tracking-widest uppercase">${t.bestSync}</div>
                                        <div className="text-pink-400 font-orbitron font-bold uppercase">${t.node}: ${highScore}</div>
                                    </div>
                                </div>
                            </div>
                        `}
                    </div>
                </div>
            `;
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    </script>
</body>
</html>
